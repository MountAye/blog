{"pageProps":{"articles":[{"slug":"error-propagation-and-philosophy-of-science","filename":"2024-10-21-error-propagation-and-philosophy-of-science.md","date":"2024-10-21","title":".tex | 误差的传递，科学之所以科学","layout":"post","keywords":["tex","phy","phi"],"excerpt":"多变量测量的误差传递，及其在科学哲学中的作用。","content":"\n如果一个物理量需要用多个直接观测量计算出来：$$y=f(x_1,x_2,...,x_n)$$，这样的量叫做因变量，直接观测量叫做自变量。（比如用直尺测量长方形面积时，长、宽是自变量，面积是因变量，通过长和宽相乘计算面积的方法是一个函数。）\n\n因为中小学减负，因变量的说法不教了，改叫函数值，为了少学一个知识点。\n\n但是学过 C/C++ 的应该知道，对于 $$y=f(x_1,x_2,...)$$\n\n- 因变量 $$y$$ 是一个左值，指向 $$y$$ 的指针 `float *p = &y;` 拿到的地址，位于内存的数据区；\n- 函数值 $$f(\\cdot)$$ 是一个右值，$$f$$ 本身就是一个指针，`void *fp = f;` 拿到的地址，位于内存的指令区。\n\n## 多变量测量的误差传递\n\n先跳过单变量误差的部分（大致原理在《贝叶斯，从公式到世界观》一文频率学派的部分，具体细节以后再写），不论是测量仪器的说明书给出的误差，还是测量者通过独立重复实验取得的统计误差，我们先假设已经拿到了观测量 $$x$$ 的测量值 $$\\bar x$$、误差 $$\\Delta x$$\n\n因为全微分公式，对于 $$y=f(x_1,x_2,...,x_n)$$\n\n$$\n\\mathrm{d}y = \\frac{\\partial f}{\\partial x_1}\\mathrm{d}x_1 + \n\\frac{\\partial f}{\\partial x_2}\\mathrm{d}x_2 + ... + \\frac{\\partial f}{\\partial x_n}\\mathrm{d}x_n = \\sum_i^n \\frac{\\partial f}{\\partial x_i}\\mathrm{d}x_i\n$$\n\n又因为误差相对于真值往往小几个数量级，所以我们把误差看作是真值的微分，用 $$\\Delta$$ 取代 $$\\mathrm{d}$$. （有人问真值为 0 怎么办，绝大多数情况下可以通过平移零点定义的办法来几乎任意地改变测量值的数量级，而误差不会因为这种变换而出现数量级变化。）\n\n还因为对多个自变量的测量是相互独立的，每个自变量 $$(x_1,x_2,...,x_n)$$ 占据相空间中的一个维度，维度之间互相正交。\n\n所以物理上，因变量的误差就是上述 ~~微分~~ 微差向量的“长度”，以  L2 范数 (norm) 来衡量：\n\n$$\n\\begin{array}{rcl}\\Delta y & = & \\sqrt{ \\left(\\frac{\\partial f}{\\partial x_1}\\bigg|_{\\vec x}\\right)^2\\Delta x_1^2 + \\left(\\frac{\\partial f}{\\partial x_2}\\bigg|_{\\vec x}\\right)^2\\Delta x_2^2 +...+ \\left(\\frac{\\partial f}{\\partial x_n}\\bigg|_{\\vec x}\\right)^2\\Delta x_n^2 } \\\\ & = & \\sqrt{\\sum_i^n{\\left(\\frac{\\partial f}{\\partial x_i}\\bigg|_{\\vec x}\\right)^2\\Delta x_i^2}}\\end{array}\n$$\n\n物理学家因此不害怕误差——理论物理的模型哪怕非常复杂，在数学上往往依然“性质优美”，只要理论的自变量可以在实验上测量，误差明确且有限，那理论给出的预测值的误差就同样明确且有限，依然可以指导实践。\n\n## 误差与可证伪性\n\n而根据卡尔·波普尔的科学哲学，具体来说就是可证伪性的划界标准，科学就不只是不害怕误差了，简直是依赖误差而生，靠误差来和伪科学划清界限。\n\n所谓科学的可证伪性，《[科学是什么？——兼谈“非科学、伪科学、反科学”和一些常见谬误](https://program-think.blogspot.com/2015/10/What-is-Science.html)》一文概括为：\n\n- 科学理论是一个相互关联的**命题**的**集合**。\n- 科学理论必须是基于**演绎**法建立整个理论体系的。也就是从不证自明的**定律**出发，依据**逻辑规则**，推论出各种各样的**定理**。\n- 理论中的命题必须是**客观**陈述，也就是能由不同的主体进行独立检验。\n- 检验的方式是**证伪**，也就是寻找现实中的一个现象，说明从理论中某个命题是错的。经过证伪程序，且没能被证伪的命题，就被验证为真。（根据逆否命题的等价性，演绎推论如果被证伪，它的逻辑前提也会连锁被证伪。那科学几百年来靠什么幸存，我们以后再狡辩～）\n- （既然一个存在命题就能否定一个学科理论中的待验证命题，）科学理论中的命题应该是**全称命题**，此即科学的普世性 (universality)。\n- 对全称命题的**特设性修正**（比如把“所有的天鹅都是白色的”修正成“所有北半球的天鹅都是白色的”），应该要提高理论的可证伪程度，否则就是伪科学。\n- 以上各个要求，单独只构成必要条件。\n\n所以定量科学的科学性就体现在，\n\n- 只要理论的自变量和因变量可以在实验上测量，\n- 自变量的误差明确且有限，那理论给出的预测值的误差就同样明确且有限，\n- 因变量的误差同样明确且有限，\n- 将理论预测值和因变量测量值摆在一起，只要差距不大于两者的误差，（技术细节在统计学中的假设检验部分。）\n- 我们就认为对“理论预测和因变量真值相等”的证伪失败了，从而接受他们相等。\n\n因为实验仪器和方法的进步可以缩小误差范围，增加科学理论的可证伪性，一条无限延展且随时可以投入精力的赛道从此出现，科学从相隔几代的少数天才之间的思维接力，变成了夙兴夜寐前赴后继的竞赛。\n\n科学家之间的竞争催生了对制造仪器之工程技术的巨大需求，需求大到部分科学家亲自下场改进甚至发明仪器，科学由此反哺技术；进步的技术使得科学得以产出更高质量的数据，支持更复杂的理论的检验。科学和技术，合成了“科技”一个词。\n\n试想一下，如果科学号称自己绝对精确，不存在误差，要么在弱小之时就被证伪，无法赢得人们的信任；要么任由实验精度低到看不出误差的程度，然后用其他手段维持自己的光辉形象。\n\n之前《也谈近代科学从西方起步》一文中说，“物理和数学的区别，在于理论和实验两条腿走路”。如今算是把实验这另一条腿简单介绍完了。\n\n最后需要注意，这里说的是某个哲学理论能够解释科学实践，而不是科学实践必须服从某套哲学理论。\n\n科学只对客观现实负责，不需要对哲学信条负责，不应该对哲学王兼英雄王负责。\n\n## 科学还正确吗？\n\n如果承认可证伪性作为科学与非科学的划界标准，也就意味着，现在包含在科学中的每条知识，都有在未来被更加精确的实验推翻的可能。\n\n这种事也不是没发生过。比如材料的电阻，在相当大的数值范围内，都和温度成线性关系，而且这条线向左延拓到绝对零度时基本为 0。在那个时代，认为电阻来自无规则的热运动，和绝对温标成正比才是符合奥卡姆剃刀原则的理论。但是 1908 年，昂内斯用液氦将汞的温度降到 4.15 K 时，发现汞的电阻突变降低为 0，这就是超导研究的开端。\n\n那还能说科学知识是正确的吗？《费曼物理学讲义》的回答是，不谈科学是不是正确的，只保证科学 (science)是科学的 (scientific)。也就是保证程序的正确，把正确程序获得的结果交给工程技术，用工程技术上的成就取信于社会，反过来为科学的正确性背书。\n\n所以说，科学家是对科学最不迷信的一批人，一旦实验过程正确，结果和理论不符，那么理论该修改的修改，该放弃的放弃。他们是现有科学最大的破坏者，是成功证伪科学命题最多的一群人。\n\n但同理，科学家又是对科学最坚定的一批人，他们在明知道一个科学命题可能在将来被修正的情况下，依然愿意把它当作前提，继续推理产出新的命题，并试图证伪。\n\n《三体》小说刚开始设置的一大悬疑，大量科学家因为自己正在进行的研究，产出了与理论完全不吻合的随机结果，因为所谓“物理学不存在了”而自杀，这个情节就很成问题。\n\n何况这种事情根本不需要书中的情节设定才会出现，物理学史上早就发生过。比如 β 衰变的质子的动能谱和动量角分布。玻尔想放弃能量守恒定律，泡利想假设一个探测器发现不了的新粒子，这在当时的实验条件下都是尚不能证伪的理论假设，但没听说俩人为这事寻死觅活的。\n\n所以改编成电视剧的时候，几乎重写整个人物关系的网飞版，把自杀改写成了球奸们伪装的他杀；就连以忠实于原作著称的腾讯版，也原创了一段主角主动重启科研装置，直面外星人恐吓的剧情，给原著做了点找补。\n\n## 那我缺的权威性这块谁给我补上啊\n\n坏了，碰到了不该碰的话题，那就先这样吧……\n\n## 报书名儿\n\n- William Lichten.《Data and Error Analysis》\n- 赵凯华《定性和半定量物理学》\n- 卡尔·波普尔《科学发现的逻辑》\n- 理查德·费曼《费曼物理学讲义》\n"},{"slug":"autumn-tour-grand-teton-and-yellowstone","filename":"2024-10-13-autumn-tour-grand-teton-and-yellowstone.md","date":"2024-10-13","title":".xls | 秋游大提顿和黄石公园","layout":"post","keywords":["doc","xls","jpg"],"excerpt":"今年秋假去了 Grand Teton 大提顿和 Yellowstone 黄石国家公园。","cover":"2024-10-13-Yellowstone.png","content":"\n今年秋假去了 Grand Teton 大提顿和 Yellowstone 黄石国家公园。两个公园南北相邻，向南最近的城镇是 Jackson Hole，也就是美联储开会的地方。\n\nGrand Teton 依托于提顿山脉，山的海拔不算特别高，但是胜在山脉东侧的湖泊和盆地，衬托得山势雄伟。园内落叶阔叶林和常绿针叶林混搭，秋季色彩明丽。\n\nYellowstone 整个公园相当于一个活火山的火山口，园内有大量温泉、间歇泉、地热，还有黄石河切削而成的峡谷和瀑布，一年四季的景色都很优美。但是园内植被主要是常绿针叶林，所以秋天并不额外出彩。\n\n另外秋季两个公园内的野生动物都不活跃，不过对于像我这样没有 100 - 400 mm 长焦镜头的普通游客影响不大～\n\n两个公园的门票都是一周内无限次进入，好处是景区内商家不存在行政垄断，吃饭加油的价格并不比外面贵；坏消息是外面和公园里一样贵，提顿村汽油每加仑超过 $5，杰克逊稍微便宜一些但也很贵。\n\n![大提顿公园地图](/photos/2024-10-13-GrandTeton.png)\n\n![黄石公园地图](/photos/2024-10-13-Yellowstone.png)\n\n### 流水账\n\n- 第一天\n    - 在盐湖城中转，期间下载了两个公园的 Google 离线地图\n    - 中午到 Jackson Hole 机场，在租车行取车\n    - 在 Dornans 下车拍照\n    - 下午开车沿 Hwy 191 向北，在沿途的停车区短停拍照，看到 Pack Trail Fire 山火的烟\n    - 经过大提顿和黄石公园南入口，分别买票\n    - 到达黄石公园 Moose 瀑布后返回\n    - 前往提顿村，路上在 Jenny Lake outlook 拍照\n    - 入住酒店\n- 第二天\n    - 从提顿村前往黄石，经过 Teton Park Road，沿途在停车区拍照\n    - 在黄石公园依次游览 West Thumb 间歇泉、Mud Volcano 火山湖、Upper & Lower 瀑布\n    - 试图前往 Dunraven ，因为不太会用离线地图，一直开到了 Roosevelt Lodge 才发现走错了，而且那里秋季不开门\n    - 返回，抵达 Dunraven Pass 时日落，没找到上山途径，在路对面的山坡上看晚霞\n    - 在公园内吃晚饭，不比宾馆贵\n    - 夜行回宾馆\n- 第三天\n    - 试图在宾馆附近拍日出，东方有山，看见太阳时高度角已经很高，未见红日\n    - 在黄石公园依次游览 Old Faithful 间歇泉、Steamboat 间歇泉、Congress pool\n    - 试图返回 Jenny lake 拍日落，没太赶上，发现另一个拍日出的机位 Cathedral Group Turnout，事后证明不是秋季的最佳机位\n- 第四天\n    - 早起前往 Cathedral Group Turnout，\n        - 看提顿峰顶的第一缕日光\n        - 在长焦镜头取景框里看到大角公鹿，没能拍下清晰照片\n        - 回程发现了更好的机位，向东可以看到地平线上的日出，向西有若干金黄色落叶阔叶林作为提顿峰的前景，非常后悔\n    - 在 Jenny lake 拍照\n    - 退房后，大提顿以东的整个平原/盆地隐没于远方山火扩散来的烟霾中\n    - 前往 Mormon Row，是一处早期定居点，遇花栗鼠一只，蓝鸟一对\n    - 穿过 Jackson 镇，进入 Elk Refuge，此处的烟霾比提顿附近略轻。\n    - 返回 Jackson 镇吃午饭，加油，回机场"},{"slug":"switched-domain-name","filename":"2024-09-30-switched-domain-name.md","date":"2024-09-30","title":"通知：本站网址変更","layout":"post","keywords":["md","html"],"excerpt":"未来可能无法自动跳转，请浏览器收藏和 RSS 订阅的读者更新网址。","content":"\n2024 年 9 月 30 日起，本站网址\n- 从 `https://mountaye.github.io/blog/` \n- 变更为 `https://blog.mountaye.com`.\n\n因为网站仍然架设在 GitHub Pages 上，所以旧网址可以自动跳转到新网址。\n\n但是下一步计划把网站迁移到 Cloudflare Pages 上，因为 Next.js 项目不同构建之间文件差异过多，不适合作为 git 仓库的内容进行托管。\n\n所以无法保证将来旧网址依然可以自动跳转。请使用浏览器收藏功能的读者更新收藏夹，使用 RSS 订阅功能的读者更新 RSS 源。\n\n根据初步计划，过渡期将持续到 2024 年 12 月 31 日。\n"},{"slug":"bayesian-equation-and-view-of-world","filename":"2024-09-27-bayesian-equation-and-view-of-world.md","date":"2024-09-27","title":".m | Bayesian 贝叶斯，从公式到世界观","layout":"post","keywords":["tex","m","phy","phi"],"excerpt":"我们老板真是太能吹了，Bro 居然跟隔壁真的在研究物理的课题组 brag abou 我会贝叶斯参数估计，yo know wat ur sayin? 赶紧来补课～","content":"\n\n## 公式\n\n我上学的时候，贝叶斯公式是概率论里面，少数高中完全不涉及，到了本科才第一次见的公式，所以我从来没背下来过。不过也用不着背，根据条件概率里面的一个平凡结果：\n\n$$\n\\Pr(A|B)\\ \\Pr(B) = \\Pr(B|A)\\ \\Pr(A)\n$$\n\n可以得到 $$\\Pr(A|B)$$ 和 $$\\Pr(B|A)$$ 之间的关系\n\n$$\n\\Pr(A|B) = \\frac{\\Pr(B|A)\\ \\Pr(A)}{\\Pr(B)}\n$$\n\n这就是贝叶斯公式本体。\n\n分母没什么意思，所以一般我们要用全概率公式替换，也就是把 $$A$$ 划分为全覆盖但是不相交的 $$\\{A_i | \\ A_i \\cap A_{j \\neq i}=\\varnothing,\\ \\bigcup_i A_i=A\\}$$\n\n$$\n\\Pr(A|B) = \\frac{\\Pr(B|A)\\ \\Pr(A)}{\\sum_i \\Pr(B|A_i) \\Pr(A_i)}\n$$\n\n其中任意一个子事件 $$A_j$$\n\n$$\n\\Pr(A_j|B) = \\frac{\\Pr(B|A_j)\\ \\Pr(A_j)}{\\sum_i \\Pr(B|A_i) \\Pr(A_i)}\n$$\n\n### 根据实验结果筛选理论模型\n\n以上是数学。在科学中，令\n\n- A 为一族理论模型的一组参数取值，记为 $$Param_k$$，下标可任意选取。\n- B 为实验观测数据，记为 *Ob*\n\n$$\n\\Pr(Param_j|Ob) = \\frac{\\Pr(Ob|Param_j)\\ \\Pr(Param_j)}{\\sum_i \\Pr(Ob|Param_i) \\Pr(Param_i)}\n$$\n\n其中 \n\n- $$\\Pr(Param_j)$$ 表示第 j 组参数是模型的正确参数的，未经实验验证，根据零假设计算的 **先验 (prior) 概率；**\n- $$\\Pr(Param_j|Ob)$$ 叫做经过实验观测修正之后的，第 j 组参数正确的 **后验 (posterior) 概率**。\n- $$\\Pr(Ob|Param_j)$$ 在之前的文章中讲过，是当前测量数据下，模型参数的 **似然性 (likelihood)**。\n\n$$\nposterior \\propto likelihood \\cdot prior\n$$\n\n### 举个例子\n\n隔壁组的问题可以简化为下图：\n\n![](/photos/2024-09-27-two-gaussian.png)\n\n- 有两组数据 (x, y1), (x, y2) 可以用同一族函数来拟合。（假设为两个高斯函数的叠加，$$y=f_{A_1,A_2,\\mu_1,\\mu_2,\\sigma_1,\\sigma_2}(x) = A_1e^{-\\frac{(x-\\mu_1)^2}{\\sigma_1^2}} + A_2e^{-\\frac{(x-\\mu_2)^2}{\\sigma_2^2}}$$\n- 两组数据的误差不同。（红色数据点显然比蓝色数据点，相对于理论值偏离得更远一些）\n- 问有没有一个数值，可以衡量每组数据的误差程度。\n\n我给他们的建议是\n\n- 根据自己的专业知识指定先验概率 $$\\Pr(param_j)=\\Pr(A_1,A_2,\\mu_1,\\mu_2,\\sigma_1,\\sigma_2)$$。比如选定一个参数空间的范围，范围之外概率为零，范围之内均匀分布。\n    - $$A_1,A_2 \\in \\left[\\min(\\{Y_1\\}\\cup \\{Y_2\\}),\\max(\\{Y_1\\}\\cup \\{Y_2\\}\\right]$$\n    - $$\\mu_1\\in[\\min\\{X\\},\\max\\{X\\}],\\ \\mu_2\\in[\\mu_1,\\max\\{X\\}]$$\n    - $$\\sigma_1,\\sigma_2\\in[0,\\ \\Sigma_i\\sqrt{|X_i-\\bar X|^2/N}]$$\n- 根据一些假设和统计规律计算 $$\\Pr(Ob|Param_j)$$\n    - 假设误差与 x 变量无关，服从期望为 0 的高斯分布，$$[y_i-f(x_i)]\\sim N(0,\\sigma^2)$$，标准差根据各数据点减去模型预测值的残差估计。\n    - 假设每个数据点的观测相互独立，$$\\Pr(Ob)=\\Pr(\\bigcap_i Ob_i)=\\prod_i\\Pr(Ob_i)$$\n    - 对于模型的每一组参数 ，$$\\Pr(Ob_i|param_j)$$ 取上述高斯分布的绝对值大于残差绝对值的部分，就是钟形曲线两侧尾巴的线下面积。\n- 对参数空间中的每一组值都算出一个后验概率之后，计算整个空间的信息熵（方法见之前的文章）。误差较大的一组数据，应当有更多组参数可以获得类似的拟合结果，从而信息熵更大。\n\n## 世界观\n\n对于概率，有三种理解：\n- 古典的 (classical)、\n- 频率学派的 (Frequentist)、\n- 贝叶斯的 (Bayesian).\n\n### 古典\n\n就是将古典概型推广，成为一种关于可能性的普遍观点——一个随机空间里的随机事件可以分解成若干子事件，子事件还可以再分，直到每个基本事件的概率相等，都等于基本事件总数的倒数，而要计算人们感兴趣的某一事件，只需要数出其包含的基本事件的数量就行了。\n\n让人联想到古希腊古典时代的原子论。时人认为物质世界也不是无限可分的，将任意一种材料打碎研磨，这一过程最终会有一个终点，最终的产物就是这种物质的“原子”。一块材料的大小，就是其所含原子数量的多少。\n\n有人批评这种观点用可能性去定义可能性，有循环论证谬误之嫌。但是看现代化了的概率论，概率被定义成了满足某些条件的函数，公理化是公理化了，逻辑链条是有了坚实的起点，但是那里的概率还能不能被当作可能性的度量，实在是不好说。\n\n有人批评这是机械唯物主义，这种人批判的武器一般是武器的批判，别争辩，先活下来再说。\n\n### 频率学派\n\n这种观点一言以蔽之：概率是频率在样本量趋于无穷时的极限。\n\n科学中（日常生活中也一样，只是人们通常没这么精确），测量误差不可避免，我们每一次的测量哪怕正确，互相之间也会有细微的差别，更不用说和待测的真实值不同了。\n\n解决方法在初中物理实验里学过：多次测量，把平均值当作真值（的估计量），根据标准差计算误差（置信区间、p 值等等……）。\n\n不同的人（假设有 M 个）可以对同一个可观测量进行 N 次测量，对于一个确定的 N，不论这个可观测量本身服从何种概率分布，这 N 个测量值的平均数 $$\\bar X_N$$ 都服从正态分布，这就是中心极限定理（注意不是大数定律）。\n\n当可观测量本身也服从正态分布的时候，就会导致标准差 (standard deviation) 和标准偏误 (standard error of the mean, 常简称为 standard error) 容易让初学者混淆。\n\n而按照这种世界观，所谓一个物理量的真值，就是所有可能的（所有已经发生过的+思想实验中可能发生的）测量的均值 $$\\bar X_\\infin$$。\n\n因为包括可能发生还未发生的测量，所以哪怕我们面对的问题是纯决定论的，客观存在一个确定的真值，无论我们已经进行过多少次测量，都无法保证得到真值。\n\n有人批评这是客观唯心主义，这种人批判的武器一般是武器的批判，别争辩，先活下来再说。\n\n### 贝叶斯\n\n前述世界观好歹还认为真值客观存在——\n\n贝叶斯世界观则直接不再对真值的客观存在下断言，不论先验还是后验，科学理论里的每一条命题，都不再孤单，而是要和所有可能的替代理论打包在一起；也不再“正确”，而是具有一个以概率衡量的可信程度。\n\n实验的作用不再是判断对错，而是在有限的先验知识（现存的科学理论）下，判断新取得的实验结果在多大程度上，更新了旧知识里每条命题的可信权重。\n\n而且每个人掌握的知识不同，先验概率不同，在同样的实验数据面前，所更新出来的知识体系也会不同。\n\n再者，如果先验概率为 0，任你实验数据如何显著，后验概率也一定为 0，所以对“未知的未知”无能为力。实践中，再离谱的先验假设，只要能想到，也要赋一个小而不为 0 的初值。\n\n有人批评这是主观唯心主义，这种人批判的武器一般是武器的批判，别争辩，先活下来再说。\n\n## 送分题\n\n已知本省不超过二十个地级行政单位。一中是本市最好的高中，本科过线人数年年创新高。\n\n已知本市报纸会公布喜报，上有全市前若干名学生的姓名、分数、录取学校等信息。省招办有根据成绩取得全省排名的服务。比如某年本市第十名，全省排名两千名开外。\n\n你能否据此评价母校和家乡的教学质量，以及本省各地区之间教育水平的平均程度？\n\n你该如何评价，从定义原假设和备择假设，到用何种概率分布对先验概率建模？\n\n你有资格评价吗？"},{"slug":"static-blog-with-nextjs-tailwindcss-shadcn","filename":"2024-09-17-static-blog-with-nextjs-tailwindcss-shadcn.md","date":"2024-09-17","title":".js | 博客改用 Next.js + TailwindCSS + Shadcn.UI","layout":"post","keywords":["md","js"],"excerpt":"我的博客本来是用 Jekyll 生成的静态网站，如今改用 Next.js + TailwindCSS + Shadcn.UI","content":"\n## 技术选型\n\n### 不再选择静态网站生成工具\n\n我的博客本来是用 Jekyll 生成的静态网站，因为网站架在 GitHub Pages 上，而 Jekyll 是 GitHub Pages 默认的构建工具。但是 Jekyll 的核心开发者年事已高，有的甚至已经去世，所以我感觉这个项目未来的活力堪忧。\n\nJekyll 是用 Ruby on Rails 写成的，其他编程语言，和 Jekyll 功能类似的工具有：\n\n- Python 的 Pelican\n- JavaScript 的 Hexo\n\n但是我还想做些更复杂的事情，预计需要靠服务端来实现。所以与其花时间移植到一个和 Jekyll 功能类似的工具，不如直接一步到位，学习一个全栈框架。\n\n### Next.js\n\n虽然不同的编程语言也都有自己的全栈框架，比如 Python 有 Django，但是既然浏览器主要支持 JavaScript，所以索性前后端都用 JS 比较方便，而且这样想的人很多，社区规模使得遇到问题更容易找到答案（这个优势在生成式语言模型的时代似乎没那么重要了）。\n\nJavaScript 语言之下，也存在至少 React 和 Vue 两大阵营。之所以选择 Next.js 这样一个基于 React.js 的框架，主要是路径依赖，很久很久以前学过[赫尔辛基大学的全栈公开课](https://fullstackopen.com/zh/)，那里教的就是 React。\n\n对于 Next.js 本身，Youtube@Fireship 有一个很简洁的介绍：[https://www.youtube.com/watch?v=Sklc_fQBmcs](https://www.youtube.com/watch?v=Sklc_fQBmcs)\n\n官网提供的教程在这里：[https://nextjs.org/learn](https://nextjs.org/learn)，和我学习的时候已经不一样了，那时候只有 page router，没有 app router。开发这一框架的 Vercel 公司也提供 Next.js 的云服务。但是鉴于其有过把用户引诱到 app router 架构然后给自家服务提价的黑历史，所以短期内不打算学和用 app router.\n\n### TailwindCSS\n\n[https://tailwindcss.com/](https://tailwindcss.com/)\n\n早就学过了，但是一直没有机会用。这次本来也可以不用的，直到决定使用 Shadcn.ui 组件库，因为 TailwindCSS 是它的一个依赖项。既然已经安装了，那不用白不用。\n\n### Shadcn.UI 而非 HeadlessUI\n\nhttps://ui.shadcn.com/\n\n一套组件库，也就是网页中经常出现的功能单元。这个库相对于竞品的最大优势，是允许直接复制粘贴代码而不用安装，用多少抄多少～\n\nTailwindCSS 自家也有一个组件库 [HeadlessUI](https://headlessui.com/)，但是主要是 `<form/>` 表单及其成员，侧重于向后端传数据的 HTML 元素的封装。而 Shacn 有很多炫酷的交互方面的组件，突出一个现成且好看。\n\n### 没用 Figma\n\n有用的功能都收钱，免费的功能不如直接 `next dev` 实时预览。\n\n## ~~踩过的坑~~ 学到的经验\n\n### 组件化作为一种思路\n\n正常的网页，HTML 负责内容，CSS 负责装饰，JavaScript 负责交互。这种分工，专业上叫做解耦。\n\n工程实践表明，这种解耦方式非常反人类。用户看到和使用的网页，是以功能上的相似、空间上的相邻为组织的，而要对其修改时，则需要到不同源代码的不同位置去；反之，某处代码的改动，无意中可能对远处的另一部分视觉效果和功能造成破坏。\n\n于是较新的全栈框架，其解耦的方式都是以组件为单位的，内容、样式、交互逻辑都写在一起。\n\n### JavaScript/JSX 语法中的 `{}`\n\nJSX 是对 JavaScript 语法的扩展，添加了类似于 HTML 标记的写法 `<MyComponent></MyComponent>`，用来表示 react 组件。\n\n在 jsx 语言的内部写 Javascript 时，需要将 JS 外面包裹一层 `{}`\n\nJavaScript 里类似 Python f-string 的结构写作``${}``，名叫 template literal: ``this is var: ${var}``\n\n——以上规则结合起来，会产生让初学者迷惑的现象：\n\n- `<MyComponent className=’dark’/>`: 一个正常的类名，直接用引号\n- `<MyComponent className={dark}/>:` 类名是一个 JS 字符串变量\n- 类名的一部分根据一个变量取值:\n  ```javascript\n  <MyComponent className={`bg-${dark}`}/>\n  ```\n\n### JavaScript 箭头函数中的 `{}` 和 `()`\n\nJavaScript 的箭头函数类似于 python 的 lambda 纯函数，但是有不同。\n\n`(var) => (expression(var))` 相当于 Python 中的 `lambda x: expression(x)` \n\n但是箭头函数的右侧可以是 `{}` 包裹的若干表达式，此时需要显式 return：\n\n```jsx\n(var) => {\n    expression1(var);\n    expression2(var);\n    return expression3(var);\n}\n```\n\nPython 的 lambda 必须是单一表达式的纯函数，不允许上面第二种写法。\n\n### 对象解包中的 `{}`\n\n当有一个包含若干键值对的对象时\n\n```jsx\nobj = {\n\t\tk1: \"value1\",\n\t\tk2: \"value2\",\n\t\tk3: \"value3\",\n\t\t...\n}\n```\n\n可以用 `const { k2 } = obj;` 的方式拿到 `obj[’k2’]` 的值，赋给 `k2`。\n\n结合上一节，\n\n- `(k1,k2)=>(k1+k2);` 是一个两个自变量的函数；\n- `({k1,k2})=>(k1+k2);` 是以一个 Object 为自变量的函数，这个 Object 的名字无所谓，也不确定一共有多少个属性，但属性中至少包含 `k1` 和 `k2`.\n\n### TailwindCSS 的 arbitrary value、JavaScript 的模板字符串、Shadcn 中的 `cn()` 函数\n\nTailwindCSS 的很多属性都允许在方括号中使用任意值，比如背景色 `bg-[#a4b4c4]`\n\n本以为可以直接在 `className` 里面用 template literal `<div className={`bg-[${myColor}]`}>`，但是并不总是生效。\n\n这个“并不总是”是个大坑，一开始在开发模式用得好好的，结果某次刷新页面之后就挂了，简直莫名其妙。\n\n好在 Shadcn 提供了一个 [`cn()` 函数](https://github.com/shadcn-ui/ui/blob/main/apps/www/lib/utils.ts)，接受一个或多个 TailwindCSS 类名字符串作为输入，就可以正常使用 template literal 了，例如 `<div className={cn(\"block\",\"border-0\",`bg-[${myColor}]`)}></div>`\n\n### HTML + CSS 布局\n\n两类套路：\n\n1. 传统的 `display`, `position`, `float` 属性；\n2. Flex 和 Grid 布局，看阮一峰先生的博客里的教程就挺方便：[Flex](https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html), [Grid](https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html).\n\n理论上后者新一些，消耗的脑力也更少一些，应该是更好的选择。\n\n但是前者也有一些优势场景。比如现在整个博客页面的上边栏和剩下的部分就是一个上下结构的 flex 布局，这导致屏幕最右侧的滚动条其实是页面一部分的，而不是整个页面的的滚动条。在 iOS 的 Safari 浏览器下，会导致网址栏不能自动隐藏，浪费很大一片屏幕空间。之后可能会换回传统功夫。\n\n而像是目录，文章跳转开头和评论区的按钮等等，需要在页面滚动时相对屏幕静止的元素，就不得不用 position，而且为了锚定在正文上，还需要嵌套好几层。\n\n按照传统功夫——\n\n- `display`可选的取值有 4 个: block | inline | inline-block | none\n    - block: 竖排，哪怕同一行内仍有空间容纳 html 中的下一个元素。\n    - inline: 横排，像文字内容一样，没有盒模型\n    - inline-block: 横排，但是有盒模型\n    - none: 不显示，和 `visibility:hidden` 的区别是，后者依然占有显示时的空间。\n- `position`可选的取值有 5 个: static | relative | fixed | absolute | sticky\n    - static: 默认值，按照 html 文件的顺序排列。\n    - relative: 相对于 static 默认值进行偏移，偏移量由 `top`, `right`, `bottom`, `left` 四个性质决定。所谓 `left: 50px` 的意思是左侧 margin 外多出 50 像素的空间，实际是向右偏移的效果。\n    - fixed: 相对于**视窗**的位置固定，位置由 `top`, `right`, `bottom`, `left` 四个性质决定。`left: 50px` 的意思是该元素的左侧 border **外沿**距离窗口左边 50 像素。\n    - absolute: 相对于最近一层父元素的位置固定，位置由 `top`, `right`, `bottom`, `left` 四个性质决定。`left: 50px` 的意思是该元素的左侧 border **外沿**距离父元素左侧**内沿** 50 像素。设计的时候需要考虑 border 宽度。\n    - sticky: 网页加载时按照 html 文件的顺序排列，直到网页滑动到某一位置，之后该元素固定在视窗，就像 fixed 一样，行为改变的位置由 `top`, `right`, `bottom`, `left` 四个性质决定。\n- `float`:  none | left | right | inherit\n    - none: 默认值，按照 html 文件的顺序排列。\n    - left: 保持在父元素左侧，其他元素环绕之。\n    - right: 保持在父元素右侧，其他元素环绕之。\n    - inherit: 和父元素的 float 的取值一致。\n\n### Unified.js 将 Markdown 文档转换为基于 JSX 的 HTML\n\nJekyll 等静态网站生成器的核心功能，就是把 markdown 文档翻译成 html 网页文档。在 Next.js 框架下，这一工作由以 unified.js 为基础的一群第三方库来完成。\n\n最早看到这个框架是在 DIYGOD 的博文《[如何优雅编译一个 Markdown 文档](https://diygod.cc/unified-markdown)》里，但是直接抄他在 xlog 里面的代码的话，在 next.js 之下好像会报错。所以又去官网仔细读了一下文档，现在可以说是略懂。\n\n这个话题本身值得专门写一篇文章，所以不在这里展开了。\n\n### Giscus 评论区切换黑夜模式\n\n自己写的组件的亮暗切换，是通过在 `<html/>` 元素添加和删除 `dark` 类，然后搭配 TailwindCSS 的 `dark:` 来实现的。\n\nGiscus 官方支持切换黑夜模式：[https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#parent-to-giscus-message-events](https://github.com/giscus/giscus/blob/main/ADVANCED-USAGE.md#parent-to-giscus-message-events)。这套方法的关键，在于服务端返回的 iframe 有一个名为 `giscus-frame` ****的类。\n\nGiscus 为 react 提供了一套组件可以直接使用，但是在这套组件里面并没有这个类。\n\n所以只能弃用官方的组件，自己用 `useEffect` 模拟官网的 `<script/>`\n\n```jsx\nexport function MyGiscus() {\n  useEffect(\n    () => {\n      const onPageLoad = () => {\n        console.log(\"<MyGiscus/>: activated on page load.\")\n        // START real business\n        const script = document.createElement('script');\n        script.src = \"https://giscus.app/client.js\";\n        script.setAttribute('data-repo',              '');\n        script.setAttribute('data-repo-id',           '');\n        script.setAttribute('data-category',          '');\n        script.setAttribute('data-category-id',       '');\n        script.setAttribute('data-mapping',           '');\n        script.setAttribute('data-strict',            '');\n        script.setAttribute('data-reactions-enabled', '');\n        script.setAttribute('data-emit-metadata',     '');\n        script.setAttribute('data-input-position',    '');\n        script.setAttribute('data-theme',             '');\n        script.setAttribute('data-lang',              '');\n        script.crossOrigin = 'anonymous';\n        script.async = true;\n        document.getElementById(\"comments\").appendChild(script);\n        // END real business\n      };\n      // Check if the page is already loaded\n      if (document.readyState==='complete') {\n        onPageLoad();\n      } else {\n        // Add event listener for page load\n        window.addEventListener('load',onPageLoad);\n        // Cleanup the event listener on component unmount\n        return () => { window.removeEventListener('load',onPageLoad); }\n      };\n    },\n    []\n  );\n  return (<div id='comments'></div>);\n}\n```\n\n### Next.js 的构建参数部分\n\n要让 next.js 构建静态网站，需要在 next.config.js 中写：\n\n```jsx\nmodule.exports = {\n  basePath: '/blog',\n  output: 'export',\n  generateBuildId: async () => \"buildID\",\n  // i18n: {\n  //   locales: ['zh-CN', 'en'],\n  //   defaultLocale: 'zh-CN',\n  //   localeDetection: false,\n  // },\n}\n```\n\n`basePath` 是因为博客的 GitHub 仓库 blog 不是默认的个人网站仓库；需要注意的是，next.js 自己的 Link 组件的 `href` 参数不需要包含这个值，但是图片等等的 `src` 参数需要。\n\n`generateBuildId` 函数的返回值是随便写的，不设定的话会导致输出里的 `_next/` 文件夹里有很多哈希值为名的文件夹，在 git 下会被当成不同的 blob 一直留在项目里。\n\n`i18n` 参数被注释掉了，因为静态生成的 next.js 项目不支持自动 i18n.\n\n### RSS 源和 sitemap\n\nRSS 由 feed 这个 npm 包来构建；\n\nsitemap 则是在 ChatGPT 的帮助下手写字符串。\n\n写好的字符串，通过在主页或者历史归档页面的 `getStaticProps()` 函数，写入 next.js 项目的 `public/` 文件夹。\n\n## 还没解决的问题\n\n### 手机端搜索框的汉字输入问题\n\n页面顶端的搜索框在手机触摸屏上，用汉字输入法输入关键词之后，直接按回车键，会导致已经输入的汉字被当成拼音，传递给搜索引擎。\n\n暂时的办法是在输入汉字之后，按回车键之前按一下空格。\n\n### Shadcn.Drawer 组件的上游代码报错；Google Ads\n\n新博客把谷歌广告撤了。赚不到多少钱不说，它还会往网页里动态添加元素，破坏原来的排版。\n\n话虽如此，每篇文章的右下角还是有个[要饭的图标](https://lucide.dev/icons/hand-heart)，计划用 shadcn 的 Drawer，放赞赏二维码，或者交换来的友站链接。\n\n但是目前 Drawer 的上游代码会报错，看起来作者已经在修复了，等更新。\n\n### Google Analytics\n\nnext.js 提供了 Google analytics: [https://nextjs.org/docs/pages/building-your-application/optimizing/third-party-libraries](https://nextjs.org/docs/pages/building-your-application/optimizing/third-party-libraries)\n\n但是加入之后没有反应，google 后台看不到，数据一落千丈。\n\n据说把相应的代码放到 `pages/_app.js` 可以解决问题，还没试。"}]},"__N_SSG":true}